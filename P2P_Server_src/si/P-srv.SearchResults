---- thread Matches (96 in 12 files) ----
AES_EnDe.c (z:\p2p_server_src\tools):	#include <pthread.h>
AES_EnDe.c (z:\p2p_server_src\tools):	typedef pthread_mutex_t				aes_mutex_t;
AES_EnDe.c (z:\p2p_server_src\tools):	#define aes_mutex_init(theMutex)	pthread_mutex_init(&theMutex, NULL)
AES_EnDe.c (z:\p2p_server_src\tools):	#define aes_mutex_lock(theMutex)	pthread_mutex_lock(&theMutex)
AES_EnDe.c (z:\p2p_server_src\tools):	#define aes_mutex_unlock(theMutex)	pthread_mutex_unlock(&theMutex)
Api.h (z:\p2p_server_src\include):   pthread_cond_t m_AcceptCond;              // used to block "accept" call
Api.h (z:\p2p_server_src\include):   pthread_mutex_t m_AcceptLock;             // mutex associated to m_AcceptCond
Api.h (z:\p2p_server_src\include):   pthread_mutex_t m_ControlLock;            // lock this socket exclusively for control APIs: bind/listen/connect
Api.h (z:\p2p_server_src\include):   pthread_mutex_t m_ControlLock;                    // used to synchronize UDT API
Api.h (z:\p2p_server_src\include):   pthread_mutex_t m_IDLock;                         // used to synchronize ID generation
Api.h (z:\p2p_server_src\include):   pthread_key_t m_TLSError;                         // thread local error record (last error)
Api.h (z:\p2p_server_src\include):      pthread_mutex_t m_TLSLock;
Api.h (z:\p2p_server_src\include):   pthread_mutex_t m_MultiplexerLock;
Api.h (z:\p2p_server_src\include):   pthread_mutex_t m_GCStopLock;
Api.h (z:\p2p_server_src\include):   pthread_cond_t m_GCStopCond;
Api.h (z:\p2p_server_src\include):   pthread_mutex_t m_InitLock;
Api.h (z:\p2p_server_src\include):   pthread_t m_GCThread;
Buffer.h (z:\p2p_server_src\include):   pthread_mutex_t m_BufLock;           // used to synchronize buffer operation
Cache.h (z:\p2p_server_src\include):   pthread_mutex_t m_Lock;
Client.cpp (z:\p2p_server_src):      pthread_create(new pthread_t, NULL, monitor, &client);
Common.h (z:\p2p_server_src\include):   #include <pthread.h>
Common.h (z:\p2p_server_src\include):   typedef HANDLE pthread_t;
Common.h (z:\p2p_server_src\include):   typedef HANDLE pthread_mutex_t;
Common.h (z:\p2p_server_src\include):   typedef HANDLE pthread_cond_t;
Common.h (z:\p2p_server_src\include):   typedef DWORD pthread_key_t;
Common.h (z:\p2p_server_src\include):   pthread_cond_t m_TickCond;
Common.h (z:\p2p_server_src\include):   pthread_mutex_t m_TickLock;
Common.h (z:\p2p_server_src\include):   static pthread_cond_t m_EventCond;
Common.h (z:\p2p_server_src\include):   static pthread_mutex_t m_EventLock;
Common.h (z:\p2p_server_src\include):   CGuard(pthread_mutex_t& lock);
Common.h (z:\p2p_server_src\include):   static void enterCS(pthread_mutex_t& lock);
Common.h (z:\p2p_server_src\include):   static void leaveCS(pthread_mutex_t& lock);
Common.h (z:\p2p_server_src\include):   static void createMutex(pthread_mutex_t& lock);
Common.h (z:\p2p_server_src\include):   static void releaseMutex(pthread_mutex_t& lock);
Common.h (z:\p2p_server_src\include):   static void createCond(pthread_cond_t& cond);
Common.h (z:\p2p_server_src\include):   static void releaseCond(pthread_cond_t& cond);
Common.h (z:\p2p_server_src\include):   pthread_mutex_t& m_Mutex;            // Alias name of the mutex to be protected
Core.h (z:\p2p_server_src\include):   pthread_mutex_t m_ConnectionLock;            // used to synchronize connection operation
Core.h (z:\p2p_server_src\include):   pthread_cond_t m_SendBlockCond;              // used to block "send" call
Core.h (z:\p2p_server_src\include):   pthread_mutex_t m_SendBlockLock;             // lock associated to m_SendBlockCond
Core.h (z:\p2p_server_src\include):   pthread_mutex_t m_AckLock;                   // used to protected sender's loss list when processing ACK
Core.h (z:\p2p_server_src\include):   pthread_cond_t m_RecvDataCond;               // used to block "recv" when there is no data
Core.h (z:\p2p_server_src\include):   pthread_mutex_t m_RecvDataLock;              // lock associated to m_RecvDataCond
Core.h (z:\p2p_server_src\include):   pthread_mutex_t m_SendLock;                  // used to synchronize "send" call
Core.h (z:\p2p_server_src\include):   pthread_mutex_t m_RecvLock;                  // used to synchronize "recv" call
Epoll.h (z:\p2p_server_src\include):   pthread_mutex_t m_SeedLock;
Epoll.h (z:\p2p_server_src\include):   pthread_mutex_t m_EPollLock;
List.h (z:\p2p_server_src\include):   pthread_mutex_t m_ListLock;          // used to synchronize list operation
Queue.h (z:\p2p_server_src\include):   pthread_mutex_t m_ListLock;
Queue.h (z:\p2p_server_src\include):   pthread_mutex_t* m_pWindowLock;
Queue.h (z:\p2p_server_src\include):   pthread_cond_t* m_pWindowCond;
Queue.h (z:\p2p_server_src\include):   pthread_mutex_t m_RIDVectorLock;
Queue.h (z:\p2p_server_src\include):   pthread_t m_WorkerThread;
Queue.h (z:\p2p_server_src\include):   pthread_mutex_t m_WindowLock;
Queue.h (z:\p2p_server_src\include):   pthread_cond_t m_WindowCond;
Queue.h (z:\p2p_server_src\include):   pthread_cond_t m_ExitCond;
Queue.h (z:\p2p_server_src\include):   pthread_t m_WorkerThread;
Queue.h (z:\p2p_server_src\include):   pthread_cond_t m_ExitCond;
Queue.h (z:\p2p_server_src\include):   pthread_mutex_t m_LSLock;
Queue.h (z:\p2p_server_src\include):   pthread_mutex_t m_IDLock;
Queue.h (z:\p2p_server_src\include):   pthread_mutex_t m_PassLock;
Queue.h (z:\p2p_server_src\include):   pthread_cond_t m_PassCond;
Server.cpp (z:\p2p_server_src):#include <pthread.h>
Server.cpp (z:\p2p_server_src):	pthread_t th_p2p_proc;
Server.cpp (z:\p2p_server_src):	ret = pthread_create(&th_p2p_proc, NULL, p2p_srvProc, (void *)NULL);
Server.cpp (z:\p2p_server_src):		cerr << "Create stun server pthread fail" <<endl;
Server.cpp (z:\p2p_server_src):	pthread_t thd_stun_t;
Server.cpp (z:\p2p_server_src):	pthread_t thd_login_t;
Server.cpp (z:\p2p_server_src):	ret = pthread_create(&thd_stun_t, NULL, stunServerThreadProc, (void *)&srvInfo);
Server.cpp (z:\p2p_server_src):		cerr << "Create stun server pthread fail" <<endl;
Server.cpp (z:\p2p_server_src):   	ret = pthread_detach(thd_stun_t);
Server.cpp (z:\p2p_server_src):			pthread_attr_t attr;
Server.cpp (z:\p2p_server_src):			pthread_t threadId;
Server.cpp (z:\p2p_server_src):			pthread_attr_init(&attr); 
Server.cpp (z:\p2p_server_src):			pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM); 
Server.cpp (z:\p2p_server_src):			pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
Server.cpp (z:\p2p_server_src):			if(pthread_create(&threadId,&attr, pthread_handle_message, (void*)&stPeer))
Server.cpp (z:\p2p_server_src):				perror("pthread_creat error!"); 
Server.cpp (z:\p2p_server_src):void* pthread_handle_message(void* para)
Server.cpp (z:\p2p_server_src):	printf("====>startSTUNserver thread start!!!\n"); 
Use_func.cpp (z:\p2p_server_src):	pthread_detach(pthread_self());  //start this thread
Use_func.cpp (z:\p2p_server_src):	pthread_exit((void*)pthread_self());  //close thread
Use_func.cpp (z:\p2p_server_src):#define	IPCAM_PTHREAD_DETACH			do{ pthread_detach(pthread_self()); }while(0)
Use_func.cpp (z:\p2p_server_src):#define	IPCAM_PTHREAD_EXIT			do{ pthread_exit((void*)pthread_self()); }while(0)
Use_func.cpp (z:\p2p_server_src):			pthread_t		__pth__;									\
Use_func.cpp (z:\p2p_server_src):			if(pthread_create(&__pth__, NULL, (void *)Func, (void *)Args))	\
Use_func.cpp (z:\p2p_server_src):			pthread_t		__pth__;									\
Use_func.cpp (z:\p2p_server_src):			if (0 == pthread_create(&__pth__, NULL, (void *)Func, (void *)Args))	\
